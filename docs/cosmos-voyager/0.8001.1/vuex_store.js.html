<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: vuex/store.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: vuex/store.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict"

/**
 * Main store module
 * @module store
 */
import Vue from "vue"
import Vuex from "vuex"
import _ from "lodash"
import * as getters from "./getters"
import modules from "./modules"

Vue.use(Vuex)

/**
 * Module Store
 * @param opts
 * @returns {Vuex.Store}
 */
export default (opts = {}) => {
  // provide commit and dispatch to tests
  opts.commit = (...args) => store.commit(...args)
  opts.dispatch = (...args) => store.dispatch(...args)

  const store = new Vuex.Store({
    getters,
    // strict: true,
    modules: modules(opts),
    actions: {
      loadPersistedState
    }
  })

  let pending = null
  store.subscribe((mutation, state) => {
    // since persisting the state is costly we should only do it on mutations that change the data
    const updatingMutations = [
      `setWalletBalances`,
      `setWalletHistory`,
      `setCommittedDelegation`,
      `setUnbondingDelegations`,
      `setDelegates`,
      `setStakingParameters`,
      `setPool`,
      `setProposal`,
      `setProposalDeposits`,
      `setProposalVotes`,
      `setGovParameters`,
      `setKeybaseIdentities`
    ]

    if (updatingMutations.indexOf(mutation.type) === -1) return

    // if the user is logged in cache the balances and the tx-history for that user
    if (!state.user.account) return

    if (pending) {
      clearTimeout(pending)
    }
    pending = setTimeout(() => {
      persistState(state)
    }, 5000)
  })

  return store
}

/**
 * Persist the state passed as parameter
 * @param state
 */
function persistState(state) {
  const cachedState = JSON.stringify({
    transactions: {
      wallet: state.transactions.wallet,
      staking: state.transactions.staking
    },
    wallet: {
      balances: state.wallet.balances
    },
    delegation: {
      loaded: state.delegation.loaded,
      committedDelegates: state.delegation.committedDelegates,
      unbondingDelegations: state.delegation.unbondingDelegations
    },
    delegates: {
      delegates: state.delegates.delegates
    },
    keybase: {
      identities: state.keybase.identities
    },
    stakingParameters: state.stakingParameters,
    pool: state.pool,
    proposals: state.proposals,
    deposits: state.deposits,
    votes: state.votes,
    governanceParameters: state.governanceParameters
  })
  // Store the state object as a JSON string
  localStorage.setItem(getStorageKey(state), cachedState)
}

/**
 * Get a storage key
 * @param state
 * @returns {string}
 */
function getStorageKey(state) {
  const chainId = state.connection.lastHeader.chain_id
  const address = state.user.address
  return `store_${chainId}_${address}`
}

/**
 * load persisted state
 * @param state
 * @param commit
 */
function loadPersistedState({ state, commit }) {
  const storageKey = getStorageKey(state)
  let cachedState
  try {
    cachedState = JSON.parse(localStorage.getItem(storageKey))
  } catch (err) {
    console.error(`Couldn't parse the cached state`)
  }
  if (cachedState) {
    // Replace the state object with the stored state
    _.merge(state, cachedState, {
      // set loading indicators to false
      transactions: {
        loaded: true,
        loading: false
      },
      wallet: {
        loaded: true,
        loading: false
      },
      delegates: {
        loaded: true,
        loading: false
      },
      proposals: {
        loaded: true,
        loading: false
      },
      pool: {
        loaded: true,
        loading: false
      },
      governanceParameters: {
        loaded: true,
        loading: false
      },
      stakingParameters: {
        loaded: true,
        loading: false
      }
    })
    this.replaceState(state)

    // add all delegates the user has bond with already to the cart
    state.delegates.delegates
      .filter(d => state.delegation.committedDelegates[d.operator_address])
      .forEach(d => {
        commit(`addToCart`, d)
      })
  }
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-App.html">App</a></li><li><a href="module-google-analytics.html">google-analytics</a></li><li><a href="module-main.html">main</a></li><li><a href="module-num.html">num</a></li><li><a href="module-PageWallet.html">PageWallet</a></li><li><a href="module-routes.html">routes</a></li><li><a href="module-store.html">store</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Wed Dec 19 2018 11:45:33 GMT+0100 (Central European Standard Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
